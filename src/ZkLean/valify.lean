/-
Copyright (c) 2022 Moritz Doll. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Moritz Doll, Mario Carneiro, Robert Y. Lewis
-/
import Mathlib.Tactic.Basic
import Mathlib.Tactic.Attr.Register
import Mathlib.Data.Int.Cast.Basic
import Mathlib.Order.Basic
import Lean.Meta.Tactic.Simp.SimpTheorems
import Lean.Meta.Tactic.Simp.RegisterCommand
import Lean.LabelAttribute
import ZkLean.AST
import Mathlib.Data.ZMod.Basic
import Mathlib.Tactic.Ring
import Mathlib.Algebra.Field.Defs
import Mathlib.Algebra.Field.ZMod
import Mathlib.Control.Fold
import Mathlib.Data.Nat.Prime.Defs
import Mathlib.Data.ZMod.Defs
import Mathlib.Algebra.Order.Kleene
import MPL
import MPL.Triple
import ZkLean
import Std.Data.HashMap.Basic
import Lean.Meta.Basic
import Lean.Elab.Term
import Mathlib.Tactic.Ring
import Std.Tactic.BVDecide
import Mathlib.Tactic.Linarith
import Mathlib.Tactic.Bound
import Mathlib.Tactic.Positivity



/-!
# `valify` tactic

Hello :)
```

```
-/

namespace Mathlib.Tactic.Valify



open Lean
open Lean.Meta
open Lean.Parser.Tactic
open Lean.Elab.Tactic


/--
Hello.
-/
syntax (name := valify) "valify" (simpArgs)? (location)? : tactic





macro_rules
| `(tactic| valify $[[$simpArgs,*]]? $[at $location]?) =>
  let args := simpArgs.map (·.getElems) |>.getD #[]
  `(tactic|
    simp -decide only [ZMod.val_sub, ZMod.val_add, ZMod.val_mul, ZMod.val_one, ZMod.val_ofNat, push_cast, norm_num, $args,*] $[at $location]? )



-- name: ZModify

-- /-- The `Simp.Context` generated by `zify`. -/
def mkZifyContext (simpArgs : Option (Syntax.TSepArray `Lean.Parser.Tactic.simpStar ",")) :
    TacticM MkSimpContextResult := do
  let args := simpArgs.map (·.getElems) |>.getD #[]
  mkSimpContext
    (← `(tactic| simp -decide only  [ZMod.val_sub, ZMod.val_add, ZMod.val_mul, ZMod.val_one, ZMod.val_ofNat, push_cast, norm_num, $args,*] )) false

/-- A variant of `applySimpResultToProp` that cannot close the goal, but does not need a meta
variable and returns a tuple of a proof and the corresponding simplified proposition. -/
def applySimpResultToProp' (proof : Expr) (prop : Expr) (r : Simp.Result) : MetaM (Expr × Expr) :=
  do
  match r.proof? with
  | some eqProof => return (← mkExpectedTypeHint (← mkEqMP eqProof proof) r.expr, r.expr)
  | none =>
    if r.expr != prop then
      return (← mkExpectedTypeHint proof r.expr, r.expr)
    else
      return (proof, r.expr)

/-- Translate a proof and the proposition into a zified form. -/
def zifyProof (simpArgs : Option (Syntax.TSepArray `Lean.Parser.Tactic.simpStar ","))
    (proof : Expr) (prop : Expr) : TacticM (Expr × Expr) := do
  let ctx_result ← mkZifyContext simpArgs
  let (r, _) ← simp prop ctx_result.ctx
  applySimpResultToProp' proof prop r



end Valify

end Mathlib.Tactic


macro "custom_sorry_macro" : tactic => `(tactic|  simp -decide only [ZMod.val_sub, ZMod.val_add, ZMod.val_mul, ZMod.val_one, push_cast, norm_num])
-- RQ: How to pass arguments into a tactic




-- example : 1 = 1 := by
--   custom_sorry_macro


-- abbrev ff := 4139
-- abbrev f := ZMod ff
-- abbrev b := Nat.log2 ff

-- instance : Witnessable (ZMod 4139) (ZMod 4139) := by sorry
-- instance : Fact (1 < n4139) := by sorry

-- @[zify_simps]
-- lemma ZMod_Sub_one (b : ZMod n) (h1: NeZero n) (h: 1 < n) (h2: b.val ≤ 1) :
--     (1 - b).val = (1 - b.val) := by
--   haveI : Fact (1 < n) := ⟨h⟩
--   rw [ZMod.val_sub]
--   rw [ZMod.val_one]
--   rw [ZMod.val_one]
--   exact h2



-- example (a b : ZMod ff) :
--   (a + b).val = (a.val + b.val) % ff := by
--   custom_sorry_macro

-- example (a b c d : ZMod 17) :
--   (( a + b + c) * d).val = (((((a.val + b.val) % 17 + c.val) % 17 )* d.val) % 17) := by
--   custom_sorry_macro


-- -- example (x y : ℕ) (h1 : x ≤ 1) (h2 : y ≤ 1) : (1 - x) * y < 17 := by
-- --   apply Nat.lt_of_le_of_lt
-- --   apply Nat.mul_le_mul

-- -- example (x y z : ZMod 17) (h: y.val <= x.val ) (h1: y.val <= ZMod.val (1 : ZMod ff))  (h2: x.val <= ZMod.val (1 : ZMod ff))  (h3: z.val <= ZMod.val (1 : ZMod ff))
-- -- (h4: y.val >= 0):
-- --   ((1- y)*z).val = ( (1 - y.val) * z.val ) := by
-- --   custom_sorry_macro
-- --   valify at h1 h2 h3
-- --   valify [h1]
-- --   simp
-- --   apply Nat.lt_of_le_of_lt
-- --   --apply Nat.lt_of_le_of_lt
-- --   apply Nat.mul_le_mul

-- --   -- seperate project with lean 4.22

-- --   --zify [h1]
-- --   --bound [h , h1 , h2 ,h3]
-- --   -- bound is a similar tactic but I think its too complicated/ does not work.
-- --   ---bound
-- --   -- RQ: Can we do a meta tactic with just apply instead of simp?
-- --   -- Seperate tactic
-- --   --- Figure out how to do apply any of the following and keep going untill none
-- --       -- <;> applies to all subgoals that are generated
-- --       --

-- --   (try apply Nat.lt_of_le_of_lt) ; (try apply lt_sub) ; (try apply Nat.mul_le_mul); (try apply h3); (try apply h1);
-- --   (try apply Nat.lt_of_le_of_lt) ; (try apply lt_sub) ; (try apply Nat.mul_le_mul); (try apply h3); (try apply h1);
-- --   (try apply Nat.lt_of_le_of_lt) ; (try apply lt_sub) ; (try apply Nat.mul_le_mul); (try apply h3); (try apply h1);
-- --   norm_num



-- --    (by norm_num)
-- --   rw [ (Nat.mul_le_mul (lt_sub y.val h1) h3)]
--   --rw [(Nat.mul_le_mul (Nat.sub_lt_add_one 1 y.val) h3)]

-- --  --simp only [Nat.lt_of_le_of_lt]

-- --   apply Nat.sub_le_self h4
-- --   simp only [Nat.sub_le_self h4, Nat.mul_le_mul h1 h3]
-- --   simp [Nat.one_mul (Nat.mul_le_mul (Nat.sub_lt_add_one 1 y.val) h3)]
-- --   --sorry
-- --  rw [Nat.mul_le_mul_left (Nat.sub_lt_add_one 1 y.val) h3 ]


example (x: ZMod 4139) (h: ZMod.val x ≤ ZMod.val (4 : ZMod ff)):
  (4 * x).val = (4 * x.val) % 4139:= by
  valify




-- example (h : x = y) : y = x := by
--   apply Eq.symm
--   trivial
