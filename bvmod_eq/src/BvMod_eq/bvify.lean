/-
Copyright (c) 2022 Moritz Doll. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Moritz Doll, Mario Carneiro, Robert Y. Lewis
-/
import Lean.Elab.Term
import Lean.LabelAttribute
import Lean.Meta.Basic
import Lean.Meta.Tactic.Simp.RegisterCommand
import Lean.Meta.Tactic.Simp.SimpTheorems
import Mathlib.Algebra.Field.Defs
import Mathlib.Algebra.Field.ZMod
import Mathlib.Algebra.Order.Kleene
import Mathlib.Control.Fold
import Mathlib.Data.Int.Cast.Basic
import Mathlib.Data.Nat.Prime.Defs
import Mathlib.Data.ZMod.Basic
import Mathlib.Data.ZMod.Defs
import Mathlib.Order.Basic
import Mathlib.Tactic.Attr.Register
import Mathlib.Tactic.Basic
import Mathlib.Tactic.Bound
import Mathlib.Tactic.Linarith
import Mathlib.Tactic.Positivity
import Mathlib.Tactic.Ring
import Mathlib.Tactic.Ring
import Std.Data.HashMap.Basic
import Std.Tactic.BVDecide
import BvMod_eq.lemmas

namespace Mathlib.Tactic.BVify

open Fin
open Lean
open Lean.Elab.Tactic
open Lean.Meta
open Lean.Parser.Tactic

lemma BitVec.ofNat_mul {w a b : ℕ} :
  BitVec.ofNat w (a * b) = (BitVec.ofNat w a) * (BitVec.ofNat w b)
  := by
    rw [BitVec.ofNat, BitVec.ofNat, BitVec.ofNat]
    rw [Fin.ofNat, Fin.ofNat,  Fin.ofNat]
    apply congrArg
    simp_all
    apply Fin.eq_of_val_eq
    simp_all

lemma ult_bv {x y : ℕ} (hx : x ≤ 1) (hy : y ≤ 1) :
  (BitVec.ofNat 8 (1 - x + x * y - y))
  = (BitVec.ofNat 8 1 - BitVec.ofNat 8 x + BitVec.ofNat 8 x * BitVec.ofNat 8 y - BitVec.ofNat 8 y)
  := by
    apply split_one at hx
    apply split_one at hy
    apply Or.elim hx
    intro hx'
    apply Or.elim hy
    intro hy'
    rw [hx']
    rw [hy']
    decide
    intro hy'
    rw [hx']
    rw [hy']
    decide
    intro hx'
    apply Or.elim hy
    intro hy'
    rw [hx']
    rw [hy']
    decide
    intro hy'
    rw [hx']
    rw [hy']
    decide

lemma BitVec.ofNat_sub_8 {b : ℕ} (h : 1 ≥ b) :
  BitVec.ofNat 8 (1 - b) = (BitVec.ofNat 8 1) - (BitVec.ofNat 8 b)
  := by
    unfold BitVec.ofNat
    rw [Fin.ofNat, Fin.ofNat,  Fin.ofNat]
    apply congrArg
    simp_all
    apply Fin.eq_of_val_eq
    simp_all
    cases b with
      | zero => simp
      | succ n => cases n with
         | zero => simp_all
         | succ m =>
            exfalso
            simp at h

lemma BitVec.ofNat_sub_32 {b : ℕ} (h : 1 ≥ b) :
  BitVec.ofNat 32 (1 - b) = (BitVec.ofNat 32 1) - (BitVec.ofNat 32 b)
  := by
    unfold BitVec.ofNat
    rw [Fin.ofNat, Fin.ofNat,  Fin.ofNat]
    apply congrArg
    simp_all
    apply Fin.eq_of_val_eq
    simp_all
    cases b with
      | zero => simp
      | succ n => cases n with
         | zero => simp_all
         | succ m =>
            exfalso
            simp at h

lemma BitVec.ofNat_sub_16 {b : ℕ} (h : 1 ≥ b) :
  BitVec.ofNat 16 (1 - b) = (BitVec.ofNat 16 1) - (BitVec.ofNat 16 b)
  := by
    unfold BitVec.ofNat
    rw [Fin.ofNat, Fin.ofNat,  Fin.ofNat]
    apply congrArg
    simp_all
    apply Fin.eq_of_val_eq
    simp_all
    cases b with
      | zero => simp
      | succ n => cases n with
         | zero => simp_all
         | succ m =>
            exfalso
            simp at h

lemma or_bv {x y : ℕ} (hx : x ≤ 1) (hy : y ≤ 1) :
  BitVec.ofNat 8 (x + y - x*y) = BitVec.ofNat 8 (x + y) - BitVec.ofNat 8 (x * y)
  := by
    apply split_one at hx
    apply split_one at hy
    apply Or.elim hx
    intro hx'
    apply Or.elim hy
    intro hy'
    rw [hx']
    rw [hy']
    decide
    intro hy'
    rw [hx']
    rw [hy']
    decide
    intro hx'
    apply Or.elim hy
    intro hy'
    rw [hx']
    rw [hy']
    decide
    intro hy'
    rw [hx']
    rw [hy']
    decide

lemma or_bv_32 {x y : ℕ} (hx : x ≤ 1) (hy : y ≤ 1) :
  BitVec.ofNat 32 (x + y - x*y) = BitVec.ofNat 32 (x + y) - BitVec.ofNat 32 (x * y)
  := by
    apply split_one at hx
    apply split_one at hy
    apply Or.elim hx
    intro hx'
    apply Or.elim hy
    intro hy'
    rw [hx']
    rw [hy']
    decide
    intro hy'
    rw [hx']
    rw [hy']
    decide
    intro hx'
    apply Or.elim hy
    intro hy'
    rw [hx']
    rw [hy']
    decide
    intro hy'
    rw [hx']
    rw [hy']
    decide

syntax (name := bvify) "bvify" (simpArgs)? (location)? : tactic

macro_rules
| `(tactic| bvify $[[$simpArgs,*]]? $[at $location]?) =>
  let args := simpArgs.map (·.getElems) |>.getD #[]
  `(tactic|
    simp -decide only [ult_bv, or_bv, or_bv_32, BitVec.ofNat_add, BitVec.ofNat_mul, BitVec.ofNat_sub_8, BitVec.ofNat_sub_32, push_cast, $args,*] $[at $location]? )

-- /-- The `Simp.Context` generated by `zify`. -/
def mkZifyContext (simpArgs : Option (Syntax.TSepArray `Lean.Parser.Tactic.simpStar ",")) :
    TacticM MkSimpContextResult := do
  let args := simpArgs.map (·.getElems) |>.getD #[]
  mkSimpContext
    (← `(tactic| simp -decide only  [ult_bv, trust_me_bv,trust_me_bv_32, BitVec.ofNat_add, BitVec.ofNat_mul, BitVec.ofNat_sub_8, BitVec.ofNat_sub_16,  BitVec.ofNat_sub_32, push_cast, $args,*] )) false

/-- A variant of `applySimpResultToProp` that cannot close the goal, but does not need a meta
variable and returns a tuple of a proof and the corresponding simplified proposition. -/
def applySimpResultToProp' (proof : Expr) (prop : Expr) (r : Simp.Result) : MetaM (Expr × Expr) :=
  do
  match r.proof? with
  | some eqProof => return (← mkExpectedTypeHint (← mkEqMP eqProof proof) r.expr, r.expr)
  | none =>
    if r.expr != prop then
      return (← mkExpectedTypeHint proof r.expr, r.expr)
    else
      return (proof, r.expr)

/-- Translate a proof and the proposition into a zified form. -/
def zifyProof (simpArgs : Option (Syntax.TSepArray `Lean.Parser.Tactic.simpStar ","))
    (proof : Expr) (prop : Expr) : TacticM (Expr × Expr) := do
  let ctx_result ← mkZifyContext simpArgs
  let (r, _) ← simp prop ctx_result.ctx
  applySimpResultToProp' proof prop r

end BVify

end Mathlib.Tactic
